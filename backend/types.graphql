# The following types define the data model of the example service
# based on which the GraphQL API is generated

type Template @model {
  id: ID! @isUnique
  title: String!
  about: String
  parameters: Parameters @relation(name: "TemplateParameter")
}

enum ParameterType {
  CLASSIFICATION
  REGRESSION
}

type Parameters @model {
  id: ID! @isUnique
  template: Template! @relation(name: "TemplateParameter")
  layers: [Layer!]! @relation(name: "ParameterLayers")
  type: ParameterType!
  shouldNormalize: Boolean!
  epochs: Int!
  loss: LossFunction!
  optimizer: Optimizer! @relation(name: "ParameterOptimizer")
  regularizer: Regularizer!
  initializer: Initializer!
}

enum Initializer {
  GLOROT_UNIFORM
  RANDOM_UNIFORM
}

enum Regularizer {
  L1
  L2
  L1_L2
}

enum LossFunction {
  MEAN_SQUARED_ERROR
  HINGE
}

enum OptimizerFunction {
  SGD
  RMSPROP
  ADAGRAD
}

enum LayerType {
  INPUT
  HIDDEN
  OUTPUT
}

enum ActivationFunction {
  SIGMOID
  LINEAR
}

type Optimizer @model {
  id: ID! @isUnique
  function: OptimizerFunction!  
  learningRate: Float!
  momentum: Float
  decay: Float
  nesterov: Boolean

  associatedParameter: Parameters @relation(name: "ParameterOptimizer")
}

type Layer @model {
  id: ID! @isUnique
  activationFunction: ActivationFunction!
  type: LayerType!
  associatedParameter: Parameters @relation(name: "ParameterLayers")
}

type User @model {
  id: ID! @isUnique
}


# # Uncomment the model below as well

# type Post @model {
#   id: ID! @isUnique
#   title: String!

#   # Every relation also required a back-relation (to determine 1:1, 1:n or n:m)
#   author: User! @relation(name: "UserPosts")
# }
